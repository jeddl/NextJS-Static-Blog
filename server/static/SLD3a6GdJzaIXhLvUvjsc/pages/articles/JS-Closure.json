{"pageProps":{"contents":"\n# JavaScript: Closure and Variable Scope\n\n## Closure\n\nClosure is one of the best features of JavaScript. It is essentially a function inside another function where the inner function has the ability to expose its variables to the calls. Meaning it has access to all the variables defined outside of the function. Here is the simple example for a closure:\n\n```js\nfunction myClosure(text) {\n    var message = \"Hello \";\n    function sayHello() {\n        console.log(message + text);\n    }\n    sayHello();\n}\nmyClosure(\"World\");\n```\n\nIn this case, the inner function `sayHello()` has the access to the variable defined in outer function `myClosure()`.\n\n### Interesting Cases\n\n#### Case I\n\nThere is a lot of resource online where you can find different usage of closure. It is a powerful tool. And here I am going to discuss some of the interesting cases along with variable scope that might cause some confusion to the beginners.\n\nWhen a closure is in a for loop, it could be something which is not what you are expecting. For example:\n\n```javascript\nvar items = {};\n\nfor (var i = 0; i < 5; i++) {\n    items[i] = function getLabel() {\n        console.log(\"Label: \" + i)\n    }\n}\n\nfor (var j = 0; j < 5; j++) {\n    items[j]();\n}\n```\n\nSo what does this code return? Obviously it is not \"0, 1, 2, 3, 4\", and instead, the output of the code is\n\n```javascript\nLabel: 5\nLabel: 5\nLabel: 5\nLabel: 5\nLabel: 5\n```\n\nWhy is that? It is because items is bound to outer-scope variable `i`, and `i` changes in each loop. After the loop, the value of `i` is updated to `5`. And this is the reason why the outputs are five 5s.\n\nSo how to get the output to be like \"0, 1, 2, 3, 4\"? Here we need to pass i as the parameter of the function instead of using it directly. This way this parameter will be made as the function's own local copy of the variable. As the result, the parameter can be passed to the function each time with current value through iteration. And it is where closure comes.\n\n```javascript\nvar items = {};\nfor (var i = 0; i < 5; i++) {\n    items[i] = getLabel(i);\n\n    function getLabel(value){\n        return function () {\n            console.log(\"Label: \" + value);\n        }\n    }\n}\n\nfor (var j = 0; j < 5; j++) {\n    items[j]();\n}\n```\n\nHere we create an inner function `getLabel()` inside `items()`, and instead of using `i` directly, we pass the `value` as the inner function parameter. So here is the output:\n\n```javascript\nLabel: 0\nLabel: 1\nLabel: 2\nLabel: 3\nLabel: 4\n```\n\n#### Case II\n\nHere is another example of closure. And as far as I know, some companies use it as their interview questions.  Here is the code:\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n    setTimeout (() => {\n        console.log(i);\n    }, 1000 * i)\n}\n```\n\nSo what do you expect it to do? The function `setTimeout()` has a callback function that is going to print out `i` on the console. And because of the async process in JavaScript and the situation we discussed above (that we are using `i` directly), the output will print out five 5s and one per second. Then how do we print out \"0, 1, 2, 3, 4\" with one number per second? Closure!\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n    ((j) => {\n        setTimeout (() => {\n            console.log(j)\n        }, 1000 * j)\n    })(i)\n}\n```\n\nHere we are using a self-invoke function that wraps the inner function up and passing the variable `i` as the parameter `j` in the loop. And we can get what we were expecting:\n\n```javascript\n// One number per second\n0\n1\n2\n3\n4\n```\n\n#### Case III\n\nFor all the scenarios we talked above, in ES6(ECMAScript 6), the newest version of JavaScript, we can use `let` instead of `var` when we define the for loop. The `let` keyword is scoped differently than `var`. So taking the above for loop as an example, in each iteration, the loop will have a new `i` where each `i` is scoped inside the loop. With increment of `i`, the iteration updates `i`'s value in the function, and as the result we don't have to use closure to achieve the goal.\n\n```javascript\nfor (let i = 0; i < 5; i++) {\n    setTimeout (() => {\n        console.log(i);\n    }, 1000 * i)\n}\n```\n\nAnd this code will give you the output of \"0, 1, 2, 3, 4\".\n\n#### Note\n\nThough closure is awesome, use it everywhere in your code might cause *memory leak*. We know that when one variable/object is not referenced, it will be reclaimed by the garbage collection mechanism. Closure will block the garbage collection when some variables/objects keep being referenced by the inner function, and they will be stored in memories. So when you finished using closure, release it.\n\n```javascript\nfunction myClosure(text) {\n    var message = \"Hello \";\n    return function sayHello() {\n        console.log(message + text);\n    };\n}\nvar myfunction = myClosure(\"World\");\nmyfunction();\nmyfunction = null;\n```\n","metadata":{"title":"JavaScript - Closure and Variable Scope","timestamp":"4/30/2018","tag":"Coding"}},"__N_SSG":true}